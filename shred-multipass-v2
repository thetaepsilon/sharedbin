#!/bin/sh
if test $# -lt 3; then echo "Usage: $0 device blocksize pass_count"; exit 1; fi;
device="$1";
bs="$2";
count="$3";

common_extras="";

# enable command line in-situ override, e.g. progress=1 shred-multipass-v2 ...
# otherwise fall back to the more conventional propogated environment variables.
if test -n "$progress"; then progress="$SHRED_PROGRESS"; fi;
if test -n "$progress" -a "$progress" -gt 0; then {
	common_extras="$common_extras status=progress";
}; fi;

if test -n "$common_extras"; then {
	echo "# picked up common extra options: $common_extras" >&2;
}; fi;

if test -n "$discard" -a "$discard" -gt 0; then {
	echo "# enabling discard at the end of each pass." >&2;
	discard=y;
}; else {
	discard="";
}; fi;

maybe_discard() {
	if test -n "$discard"; then {
		echo "# end of pass discard..." >&2;
		blkdiscard "$1" || echo "# warning: discard $1 failed" >&2;
	}; fi;
};

mkwipedata() {
	# data to wipe only has to be random on a per-block basis.
	# we're not trying to hide anything, but *destroy* old patterns
	# (otherwise a zero wipe would be sufficient).
	path=$(mktemp) || return $?;
	dd if=/dev/urandom bs="$bs" count=1 iflag=fullblock of="$path" $common_extras || return $?;
	echo "$path";
}
runpass() {
	input=$(mkwipedata) || return $?;
	(while cat "$input"; do :; done) | dd iflag=fullblock bs="$bs" oflag=direct of="$device";
	rm "$input" || echo "warning: can't clean up input data temp file" >&2;
}



echo "Device $device will be erased in $count (+ 1) passes using blocksize $bs.";
echo "You have 10 seconds to abort the process.";
sleep 10;
echo "Starting erasure...";
for i in $(seq -- "$count"); do {
	echo "Starting random data pass, $i of $count";
	if runpass; then {
		echo "pass $i complete.";
	}; else {
		echo "warning: error occured during pass $i" >&2;
	}; fi;
}; done;
echo "Starting zero-fill erase pass...";
dd if=/dev/zero bs="$bs" iflag=fullblock oflag=direct of="$device" $common_extras;
echo "Blank pass completed.";
